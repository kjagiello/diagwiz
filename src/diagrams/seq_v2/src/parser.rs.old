#![allow(dead_code)]

use pest::{Parser, Span};

#[derive(Parser)]
#[grammar = "syntax.pest"]
struct SequenceDiagramParser;

#[derive(Debug, PartialEq)]
pub enum ParserError {
    SyntaxError(String),
}

pub struct Alias {
    pub id: String,
    pub label: String,
}

pub struct Source {
    pub pos: (usize, usize),
}
pub struct ItemWithSource<I>(I, Source);

#[derive(Default)]
pub struct SequenceDiagram {
    pub aliases: Vec<ItemWithSource<Alias>>,
}

pub fn add_context<C>(item: C, span: Span) -> ItemWithSource<C> {
    ItemWithSource(
        item,
        Source {
            pos: (span.start(), span.end()),
        },
    )
}

pub fn parse(input: &str) -> Result<SequenceDiagram, ParserError> {
    let ast = SequenceDiagramParser::parse(Rule::main, input);
    match ast {
        // TODO: rename
        Ok(mut ast) => {
            let mut diag = SequenceDiagram::default();
            for stmt in ast.next().unwrap().into_inner() {
                match stmt.as_rule() {
                    Rule::alias => {
                        let span = stmt.as_span();

                        // { ^"alias" ~ name ~ "=" ~ string }
                        let mut inner_rules = stmt.into_inner();

                        let name: &str = inner_rules.next().unwrap().as_str();
                        let value: &str = inner_rules.next().unwrap().as_str();

                        diag.aliases.push(add_context(
                            Alias {
                                id: String::from(name),
                                label: String::from(value),
                            },
                            span,
                        ));
                    }
                    _ => (),
                }
            }
            Ok(diag)
        }
        Err(e) => Err(ParserError::SyntaxError(e.to_string())),
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn parse_diagram_empty() {
        let data = "";
        let result = parse(data).unwrap();
        assert_eq!(result.aliases.len(), 0);
    }

    #[test]
    fn parse_diagram_alias() {
        let data = "alias a = \"b\"";
        let result = parse(data).unwrap();
        assert_eq!(result.aliases.len(), 1);
        let ItemWithSource(alias, source) = &result.aliases[0];
        assert_eq!(alias.id, "a");
        assert_eq!(alias.label, "b");
        assert_eq!(source.pos, (0, 13));
    }
}
